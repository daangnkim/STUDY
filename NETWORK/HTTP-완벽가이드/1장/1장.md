### 프로토콜 버전

1. HTTP 0.9 (1991년)
- GET 메서드만 지원, 상태 코드, 버전 번호, HTTP 헤더,  MIME 타입 지원 안함

2. HTTP 1.0 (1996년)
- POST, HEAD 메서드 추가. 상태 코드, 버전 번호, HTTP 헤더,  MIME 타입 지원
- If-modified-since를 이용해서 캐싱지원
- keep-alive 커넥션 지원

3. HTTP 1.1 (1997년)
- PUT, DELETE 메서드 추가
- 다중 요청/응답 불가능
    
    HTML 문서 내의 여러가지 요청, CSS 파일 로드하는 Link태그, 이미지 파일을 로드하는 img 태그, 자바스크립트를 로드하는 script 태그 등은 개별적으로 전송되고 개별적으로 응답
    
    이와 달리, HTTP 2.0은 다중 요청/응답 가능
    
- 추가적인 캐싱지원, entity tag(Etag): 두 리소스가 동일한지, cache-control: 캐싱 정책 정의
- if-unmodified-since, if-match, if-none-match 추가
- 모든 TCP 커넥션은 지속 커넥션
- 파이프라이닝

https://stackoverflow.com/questions/246859/http-1-0-vs-1-1

4. HTTP 2.0 (2015년)
- HTTP 1.1 단점 보완 및 성능 개선
- 구글의 SPDY(SPEEDY 발음) 프로토콜 기반
- 텍스트 방식의 메시지 대신 이진 포맷 사용 → 프로토콜 자체를 경량화.
    
    헤더와 페이로드를 프레임으로 추상화
    
- 스트림, 메시지, 프레임 3개의 단위가 존재.
    - 스트림은 양방향으로 주고받는 하나 이상의 메시지
    - 메시지는 요청 혹은 응답
    - 프레임은 제일 작은 정보 단위로 헤더나 페이로드 둘 중 하나
    - 프레임이 모이면 메시지
    - 메시지가 모이면 스트림

![[Pasted image 20250706223846.png]]

- multiplexed 스트림
    - 하나의 커넥션에 여러 개의 스트림 동시에 오픈 및 전송 가능 → 병렬 커넥션 문제 해결
    - 우선순위 가질 수 있음
    - 클라이언트 요청과 서버의 응답이 비동기 방식(순서에 상관없이 전달)으로 이루어짐 → HOL 문제 해결

![[Pasted image 20250706223907.png]]

- 헤더 압축
    - HTTP/1.1 버전까지 Content-Encoding 알고리즘 통해서, 서버에서 HTTP 페이로드 압축
        
        헤더는 압축 없이 받는 문제, 같은 헤더 정보를 중복해서 주고받는 문제
        
    - HTTP/2 에서는 클라이언트와 서버 사이의 가상 테이블을 만들어서 중복전달 해결
        
        중복되는 경우, 테이블 인덱스만 전달
        
    - 헤더 압축 알고리즘 HPACK 사용. 허프만 알고리즘으로 압축
- 서버 푸시
    - 클라이언트의 요청이 없어도 서버가 응답을 알아서 보내는 기능

1. HTTP 3.0
- HTTP/2.0의 TCP 단점 해결
- UDP 기반(UDP 빠른 성능)의 QUIC(Quick UDP Internet Connection) 사용하여 TCP 성능 개선
- ZeroRTT 기술
    RTT는 송신자와 수신자가 연결을 맺는 데 걸리는 시간
    이전에 클라이언트가 한 번이라도 접속했던 서버라면 바로 데이터를 보내는 기술
    

### 웹 애플리케이션 종류

인터넷과 상호작용 할 수 있는 웹 애플리케이션은 많음.

1. 프록시
- 보안, 성능 최적화를 위해 사용 (바이러스 검사, 성인 컨텐츠 차단, 캐시 프록시)
- 클라이언트와 서버 사이에 위치하여, 모든 HTTP 요청을 받아 서버에 전달. 사용자 대신 서버에 접근

2. 캐시
- 웹 캐시, 웹 프록시는 자주 찾는 문서의 사본을 복사해 두는 HTTP 프록시 서버

3. 게이트웨이
- 다른 서버들의 중개자로 동작
- HTTP 프로토콜 트래픽을 다른 프로토콜 트래픽으로 변환
- 진짜 서버인 것처럼  요청을 다루므로, 클라이언트는 게이트웨이와 통신하고 있음을 알아채지 못함

4. 터널
- HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법
- 터널을 사용하면 HTTP 커넥션을 통해서, HTTP가 아닌 트래픽 전송 가능

![[Pasted image 20250706224240.png]]

5. 사용자 에이전트
- 사용자를 위해 HTTP 요청을 만들어주는 프로그램
- 대표적인 예로 브라우저 존재

### URI, URL, URN

- URL과 URN은 URI의 부분 집합
    - URL은 리소스의 구체적인 위치
    - URN은 위치에 영향받지 않는 유일무이한 이름 (`urn:isbn:978-0134685991` (책의 ISBN))
- URL은 HTTP 프로토콜 뿐만 아니라, 다른 프로토콜도 가능
    - mailto:president@whitehouse.gov
    - ftp://ftp.lots-o-books.com/pub/complete-price-list.xls
    - rtsp://www.joes-hardware-com:554/interview/cto_video
- URL을 통해서 리소스에 쉽게 접근 가능
    - FTP 서버에 접근하려고 FTP 클라이언트 필요 없음
    - 메일 전송하려고 메일 프로그램 필요 없음
- URN은 리소스가 존재하는 한 변경되지 않음 

### URL 문법

- URL 문법은 스킴에 따라서 달라짐. 큰 차이는 없음
- 일반적으로 9개 부분으로 나뉨
    - <스킴>://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
2. 호스트와 포트
- 호스트는 리소스를 가지고 있는 호스트 장비
- 포트는 서버가 열어놓은 네트워크 포트

3. 사용자 이름과 비밀번호
- FTP 서버에서 요구

4. 경로
- 리소스의 위치
- 각 경로조각은 자체만의 파라미터 가짐

5. 파라미터
- 이름=값 쌍의 리스트

6. 질의
- 이름=값 쌍의 리스트
- &로 구분

7. 프래그먼트
- 리소스의 특정 부분 가리킴(텍스트 문서에서 특정 절)
- 서버는 객체 일부가 아닌 전체만 다룸. 클라이언트는 서버에 프래그먼트를 전달하지 않음.

![[Pasted image 20250706224405.png]]

### 상대 URL

- 상대 URL은 ./hammers.html
- 기저 URL은 http://www.joes-hardware.com/tools.html
- 절대 URL은 http://www.joes-hardware.com/hammers.html
- 위치를 변경하더라도 새로운 기저 URL에 의해 해석

### URL 확장

- 브라우저는 URL 자동 확장
1. 호스트명 확장
- yahoo를 입력하면 [www.yahoo.com](http://www.yahoo.com)으로 확장

1. 히스토리 확장
- 사용자가 방문했던 URL 저장
- http://www.joes- 입력하면 http://www.joes-hardware.com 으로 확장

### URL에서 안전하지 않은 문자, 이스케이프 처리

- **URL에서 안전하지 않은 문자를 안전한 문자로 바꿈**
- URL은 어떤 인터넷 프로토콜에서든 안전하게(정보가 유실될 위험 없이) 전송 & 가독성 되어야(있어야) 함.
    
    SMTP는 특정 문자를 제거할 수도 있는 방식 사용. 그러므로 URL은 상대적으로 작고, 일반적으로 안전한 문자만(ASCII 문자 집합 일부) 허용.
    
     이외의 문자를 포함하는 경우 이스케이프(안전한 문자로 바꿈, 인코딩) 처리
    
- 인코딩은 % 뒤에 16진수 두 자리. 공백의 경우, %20

※ 이스케이프 시퀀스는 유니코드 문자들중 키보드로 표현하기 어려운 문자 표현 (\t, \n)